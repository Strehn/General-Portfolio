/*  main.cpp
 * CYK Algorithm
 *  Created by Sydney Petrehn on 12/1/19.
 *  Copyright Â© 2019 Sydney Petrehn. All rights reserved.
 *  Notes about the grammar: In the grammar file there can be no spaces
 *  So an example looks like this:
 *  A->BA|a
 *  B->CC|b
 *  C->AB|a
 */
#include <iostream>
#include <fstream>
using namespace std;

/* ----- Global Variables -----
 * Stores the grammar and the number of productions
 * For use throughout every function
 */
#define MAX 100
#define for(i,a,b) for(i=a;i<b; i++)
string gram[MAX][MAX]; //grammar array to hold productions
string gram_rule[MAX];
int prod,np; // prod is current production working on, np is total number
 
/* ----- Functions -----
*  Functions handle parsing the grammar, checking for CNF, and checking if word is part
*  of the grammar.
*/
string concat(string a, string b);
void parse_gram(string a);
int rcnf(string a);
string search_prod(string p);
string gen_comb(string a, string b);

/*
* ----- Main Function -----
*/
int main()
{
    /*
    * ----- Variables -----
    */
    int i,pt,j,str_len,k,cont,user_input;
    string gram_str,test_str,r,pr,start, gram_test;
    ifstream infile;
    string matrix[MAX][MAX],st;
    
    /*
    * Get the grammar from the file
    * Get the Start Variable, Number of Productions, and word from the user
    */
    
    infile.open("Grammar.txt"); // edit this file to change the grammar
    if(!infile)
    {
        cout<<"\n Failure to open file: ";
    }
    
    cout<<"\nEnter the start Variable ";
    cin >> start;
    cout<<"\nNumber of productions ";
    cin >> np;
    
    //Input the grammar from the file stream infile
    for(i,0,np)
    {
        cout<<"\nProduction line read from file correctly";
        infile >> gram_str; // reads production line from the file.
        pt = gram_str.find("->"); // looks like S->A|B so inputs both sides of ->
        gram[i][0] = gram_str.substr(0,pt); //left side (Variable)
        
        /*
        * Tests the left side of the -> for CNF, so should be one character of the Alphabet
        */
        gram_test = gram_str.substr(0,pt); // do this to test for CNF
        if (!( (gram_test.length()==1) && (gram_test[0]>='A') && (gram_test[0]<='Z') ) )
        {
            cout<<"\nGrammar not in Chomsky Form";
            abort();
        }
        
        /*
        * Tests the right side of the -> for CNF, looking for either productions or terminal symbols
        */
       gram_str = gram_str.substr(pt+2, gram_str.length()); // right side of ->
        parse_gram(gram_str); // looks for any | seperating productions
        for(j,0,prod)
        {
            gram[i][j+1]=gram_rule[j];
            if (rcnf(gram_rule[j]) == 0) // makes sure it is in CNF
            {
                cout<<"\nGrammar not in Chomsky Form";
                abort();
            }
        }
    }
        
    /*
    * ----- While Loop -----
    * loop to test multiple strings against the same grammar
    */
    cont = 0;
    while (cont == 0)
    {
        cout<<"\nEnter string to be checked : ";
        cin >> test_str;
    
        /*
        *
        * Assigns values to principal diagonal of matrix
        *
        */
        for(i,0,test_str.length())
        {
            r="";
            st = "";
            st+=test_str[i];
            for(j,0,np)
            {
                k=1;
                while(gram[j][k] != "")
                {
                    if(gram[j][k] == st)
                    {
                        r=concat(r,gram[j][0]);
                    }
                    k++;
                }
            }
            matrix[i][i]=r;
        }
        
           /*
           *
           * Assigns values to upper half of matrix
           *
           */
        for(k,1,test_str.length())
        {
            for(j,k,test_str.length())
            {
                r="";
                for(str_len,j-k,j)
                {
                    pr = gen_comb(matrix[j-k][str_len],matrix[str_len+1][j]);
                    r = concat(r,pr);
                }
                matrix[j-k][j] = r;
            }
        }
     
        /*
        *
        * Prints the matrix
        *
        */
        for(i,0,test_str.length())
        {
            k=0;
            str_len=test_str.length()-i-1;
            for(j,str_len,test_str.length())
            {
                cout<<setw(5)<<matrix[k++][j]<<" ";
            }
            cout<<endl;
        }
            
        /*
        *
        * Looks to see if word can be generated by the grammar and it does this by looking
        * for a start symbol in the last element of the first row. If there is one then it
        * is able to be generated if not then it isnt able to be generated
        */
        for(i,0,start.length())
            if(matrix[0][test_str.length()-1].find(start[i]) <= matrix[0][test_str.length()-1].length())
            {
                cout<<"String can be generated\n";
                /* Example of what this should look like
                SAC
                     SCA
                       B     B
                AS     B    SC    AS
                 B    AC    AC     B    AC
                 */
            }
            else
                {cout<<"String cannot be generated\n";}
         /* Example of what this should look like
              A
          SC          AS
          AC     B     B    AC
          */
       
        /*
        * Asks the user if they want to test again.
        * Would be if they wanted to test another string against the grammar
        */
        cout<<"Do you want to test another string?\n Yes (0) \n No(1) \n";
        cin >> user_input;
            if (user_input == 1)
            {
                cont = 1; // User doesn't want to test another string, exit the while loop.
            }
    }// end of while loop
    return 0;
} // end of main

/*
 * ----- FUNCTION DEFINITIONS -----
 */

/*
* concatenates unique non-terminals
*/
string concat(string a, string b)
{
    int i;
    string r=a;
    for(i,0,b.length())
        if(r.find(b[i]) > r.length())
            r+=b[i];
    return (r);
}
 

/*
* Parses the grammar rules by Looks for the | seperating the productions of the grammar and adding rules to gram_rule[]
*/
void parse_gram(string a)
{
    int i;
    prod=0;
    while(a.length())
    {
        i=a.find("|");
        if(i>a.length())
        {
            gram_rule[prod++] = a; // adds to the grammar rule since there is only one rule
            a=""; // changes a to "" so we know we are done reading
        }
        else
        {
            gram_rule[prod++] = a.substr(0,i); // adds the left of | to grammar rules
            a=a.substr(i+1,a.length()); // adds the right of the | as another rule
        }
    }
}
 

/*
* Checks if the Symbol on the right is one character and a letter
*/
int rcnf(string a)
{
    if (a.length() == 1 && a[0]>='a' && a[0] <='z') // can be a terminal
        return 1;
    if (a.length()==2 && a[0]>='A' && a[0]<='Z' && a[1]>='A' && a[1]<='Z' ) // or can be another production
        return 1;
    return 0;
}

 /*
 * returns a string of variables which can produce string p
 */
string search_prod(string p)
{
    int j,k;
    string r="";
    for(j,0,np)
    {
        k=1;
        while(gram[j][k] != "")
        {
            if(gram[j][k] == p)
            {
                r=concat(r,gram[j][0]);
            }
            k++;
        }
    }
    return r;
}

 /*
 * creates every combination of variables from a and b . For eg: BA * AB = {BA, BB, AA, BB}
 */
string gen_comb(string a, string b)
{
    int i,j;
    string pri=a,re="";
    for(i,0,a.length())
        for(j,0,b.length())
        {
            pri="";
            pri=pri+a[i]+b[j];
            re=re+search_prod(pri);     //searches if the generated productions can be created or not
        }
    return re;
}
